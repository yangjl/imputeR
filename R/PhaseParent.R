#' \code{Phasing haplotypes of focal parent}
#'
#' Phasing haplotypes using parents' genotype data and progeny array's genotypic data.
#' Parents' genotypic data can be either confident genotyping data, i.e., WGS data, or 
#' imputed genotypic data generated by \code{impute_parent}. This function was composed of two major parts: 
#' \code{phase_chunk} and \code{join_chunks}.
#'
#' @param GBS.array A GBS.array object generated from create_GBS.array() or sim.array() functions.
#' @param win_length A list of vectors of Kid's GBS data. Coded with 0, 1 and 2, which is the copy of alternative alleles. 
#' Missing data should be coded with 3.
#' @param join_len
#' @param hom.error Homozygous error rate, default=0.02. Used for construction of error metrics.
#' @param het.error Heterozygous error rate, default=0.8. Used for construction of error metrics.
#' @param imiss The cutoff used for determining the log likelihood ratio of the highest and the 2nd highest genotypes. 
#' The oddratio = NULL means to report the most likely genotype. Default value sets to 0.5.
#' @param verbose For function 'genomom', returnall=TRUE will return with all the information; returnall=FALSE will return
#' mom's genotype only.
#' 
#' @return return a data.frame with all the log likelihoods. Using function \code{momgeno} to extract mom's genotype. 
#'   
#'   See \url{https://github.com/yangjl/imputeR/blob/master/vignettes/imputeR-vignette.pdf} for more details.
#'   
#' @examples
#' obs_mom <- c(0, 0, 0)
#' obs_kids <- list(c(0, 0, 0), c(0, 0, 0), c(0, 0, 0), c(0, 0, 0), c(0, 0, 0), c(0, 0, 0),
#' c(0, 0, 0), c(0, 0, 0), c(0, 0, 0), c(0, 0, 0), c(0, 0, 0), c(0, 0, 0))
#'
#' impute_parent(obs_mom, obs_kids, hom.error=0.02, het.error=0.8)
#' 
#' GBS.array <- sim.array(size.array=50, numloci=1000)
#' 
#' 
PhaseParent <- function(GBS.array, win_length=10, join_len=10, hom.error=0.02, het.error=0.8, imiss=0.2,
                       verbose=TRUE, unphased_mom=FALSE){
    
    dad_geno <- GBS.array@gbs_parents
    mom_array <- GBS.array@gbs_parents
    progeny <- GBS.array@gbs_kids
    ped <- GBS.array@pedigree
    
    ### get probability matrices
    #gen_error <- gen_error_mat(hom.error, het.error)
    probs <- error_mx(hom.error, het.error, imiss)
    
    #### phasing chunks
    if(verbose){ message(sprintf("###>>> start to phase halpotype chunks ...")) }
    haps <- setup_haps(win_length) 
    chunklist <- phase_chunk(GBS.array, haps, verbose, win_length)
    
    #### joining chunks
    if(verbose){ message(sprintf("###>>> start to join hap chunks ...")) } 
    if(length(haplist) > 1){
        out <- join_chunks(GBS.array, chunklist, verbose, join_len)
        if(verbose){ message(sprintf("###>>> Reduced chunks from [ %s ] to [ %s ]", length(haplist), length(out))) } 
        haplist <- out
    }
    
    #### return data.frame
    out <- write_mom(haplist)
    hetsites <- which(dad_geno==1)
    if(verbose){ message(sprintf("###>>> phased [ %s (%s/%s) ] heter sites", 
                                 round(nrow(out)/length(hetsites),3), nrow(out), length(hetsites) )) } 
    return(out)
}

#'
#' \code{Phasing Parent's haplotypes into chunks. } 
#'
#' Phasing haplotypes using parents' genotype data and progeny array's genotypic data.
#' Parents' genotypic data can be either confident genotyping data, i.e., WGS data, or 
#' imputed genotypic data generated by \code{impute_parent}.
#'
#' @param GBS.array A GBS.array object generated from create_GBS.array() or sim.array() functions.
#' @param win_length A list of vectors of Kid's GBS data. Coded with 0, 1 and 2, which is the copy of alternative alleles. 
#' Missing data should be coded with 3.
#' @param haps all possible haplotypes
#' @param verbose For function 'genomom', returnall=TRUE will return with all the information; returnall=FALSE will return
#' mom's genotype only.
#' 
#' @return return a data.frame with all the log likelihoods. Using function \code{momgeno} to extract mom's genotype. 
#'   
#'   See \url{https://github.com/yangjl/imputeR/blob/master/vignettes/imputeR-vignette.pdf} for more details.
#' @examples
#' 
#' 
#' GBS.array <- sim.array(size.array=50, numloci=1000)
#' haps <- setup_haps(win_length) 
#' haplist <- phase_chuck(GBS.array, haps, verbose, win_length)
#' 
phase_chunk <- function(GBS.array, haps, verbose, win_length){
    
    ped <- GBS.array@pedigree
    fidx <- unique(ped$p1)
    if(length(fidx) == 1){
        hetsites <- which(GBS.array@gbs_parents[[fidx]]==1)
    }else{
        stop("!!! error! more than one focal parent in pedigree !!!")
    }
    
    # gets all possible haplotypes for X hets 
    dad_phase1 = dad_phase2 = as.numeric() 
    win_hap = old_hap = nophase = as.numeric() 
    haplist <- list()
    
    winstart <- i <- 1
    ###### print progress bar
    pb <- txtProgressBar(min = winstart, max = length(hetsites)-(win_length-1), style = 3)
    
    ## think about hetsites=0 or hetsites < win_length
    while(winstart <= length(hetsites)-(win_length-1) ){
        if(verbose){ setTxtProgressBar(pb, winstart) } 
        winidx <- hetsites[winstart:(winstart+win_length-1)]
        if(winstart==1){ 
            #arbitrarily assign win_hap to one chromosome initially
            # get the most likely dad haplotype, NULL is not allowed
            win_hap <- infer_dip(GBS.array, winidx, haps, returnhap=TRUE)
            dad_phase1 <- win_hap
            dad_phase2 <- 1-win_hap
            idxstart <- 1
        } else{
            win_hap <- infer_dip(GBS.array, winidx, haps, returnhap=FALSE)
            ### comparing current hap with old hap except the last bp for hap extension
            if(!is.null(win_hap)){
                
                same=sum(dad_phase1[(length(dad_phase1)-win_length+2):length(dad_phase1)]==win_hap[1:length(win_hap)-1])
                
                if(same == 0){ #totally opposite phase of last window
                    dad_phase2[length(dad_phase2)+1] <- win_hap[length(win_hap)]
                    dad_phase1[length(dad_phase1)+1] <- 1-win_hap[length(win_hap)]
                } else if(same==(win_length-1) ){ #same phase as last window
                    dad_phase1[length(dad_phase1)+1] <- win_hap[length(win_hap)]
                    dad_phase2[length(dad_phase2)+1] <- 1-win_hap[length(win_hap)]
                } else{
                    diff1 <- sum(abs(dad_phase1[(length(dad_phase1)-win_length+2):length(dad_phase1)]-win_hap[1:length(win_hap)-1]))
                    diff2 <- sum(abs(dad_phase2[(length(dad_phase1)-win_length+2):length(dad_phase1)]-win_hap[1:length(win_hap)-1]))
                    if(diff1 > diff2){ #dad_phase1 is less similar to current inferred hap
                        dad_phase2[length(dad_phase2)+1] <- win_hap[length(win_hap)]
                        dad_phase1[length(dad_phase1)+1] <- 1-win_hap[length(win_hap)]
                    } else{ #dad_phase1 is more similar
                        dad_phase1[length(dad_phase1)+1] <- win_hap[length(win_hap)]
                        dad_phase2[length(dad_phase2)+1] <- 1-win_hap[length(win_hap)]
                    }
                }
            } else {
                ### potential recombination in kids, output previous haps and jump to next non-overlap window -JLY###
                idxend <- winstart + win_length -2
                haplist[[i]] <- list(dad_phase1, dad_phase2, hetsites[idxstart:idxend])
                i <- i +1
                
                ### warning(paste("Likely recombination at position", winstart+1, sep=" "))
                ### if new window is still ambiguous, add 1bp and keep running until find the best hap
                winstart <- winstart + win_length -2
                while(is.null(win_hap)){ 
                    winstart <- winstart + 1
                    win_hap <- jump_win(GBS.array, winstart, win_length, hetsites, haps)
                    if(is.null(win_hap)){
                        nophase <- c(nophase, hetsites[winstart])
                    }
                }
                idxstart <- winstart
                dad_phase1 <- win_hap
                dad_phase2 <- 1-win_hap
            }
        }
        winstart <- winstart + 1
    }
    close(pb)
    ### return the two haplotypes
    #myh1 <- replace(estimated_mom/2, hetsites, mom_phase1)
    #myh2 <- replace(estimated_mom/2, hetsites, 1-mom_phase1)
    #return(data.frame(h1=myh1, h2=myh2))
    #if(verbose){ message(sprintf(">>> phasing done!")) }
    haplist[[i]] <- list(dad_phase1, dad_phase2, hetsites[idxstart:length(hetsites)])
    ## list: hap1, hap2 and idx; info
    return(haplist)
    #return(list(haplist=haplist, info=list(het=hetsites, nophase=nophase)))
}

#' @rdname phase_chunk
infer_dip <- function(GBS.array, winidx, haps, returnhap=FALSE){  
    # momwin is list of heterozygous sites, progeny list of kids genotypes, 
    # haps list of possible haps,momphase1 is current phased mom for use in splitting ties
    #### function for running one hap ####
    phase_probs <- unlist(lapply(1:length(haps), function(a) {
        sum_max_log_1hap(GBS.array, winidx, dad_hap=haps[[a]])
        }))
    #if multiple haps tie, check each against current phase and return one with smallest distance
    if(length(which(phase_probs==max(phase_probs)))>1){
        if(returnhap){
            return(haps[[sample(which(phase_probs==max(phase_probs)), 1)]])
        } else{
            return(NULL)
        }
    }else{
        return(haps[[which.max(phase_probs)]])
    } 
}

#' @rdname phase_chunk
#' log likelyhood of one focal parent's hap x all other haps for all kids
sum_max_log_1hap <- function(GBS.array, winidx, dad_hap=haps[[a]]){
    
    ped <- GBS.array@pedigree
    pgeno <- GBS.array@gbs_parents
    kgeno <- GBS.array@gbs_kids
    
    ### for outcrossed kids: 
    ped1 <- subset(ped, p1 != p2)
    maxlog1 <- lapply(1:nrow(ped1), function(x) {
        mymom <- pgeno[[ped1$p2[x]]]
        if(!is.null(nrow(mymom))){ #phased mom
            temmom <- mymom[winidx, ]
            mom_geno <- temmom$hap1 + temmom$hap2
            if(length(unique(temmom$chunk))==1){
                mom_haps <- list(mymom[winidx, ]$hap1, mymom[winidx, ]$hap2)
            }else{
                haps1 <- setup_haps(length(unique(temmom$chunk)))
                haps2 <- lapply(1:length(haps1), function(x) 1-haps1[[x]])
                allhaps <- c(haps1, haps2)
                mom_haps <- lapply(1:length(allhaps), function(x){
                    
                    temout <- c()
                    k = 1
                    for(c in unique(temmom$chunk)){
                        temout <- c(temout, temmom[temmom$chunk==c, allhaps[[x]][k]+1])
                        k <- k+1
                    }
                    return(temout)    
                })}    
        }else{ #unphased mom
            mom_geno <- mymom[winidx]
            het_idx <- which(mom_geno==1)
            if(length(het_idx) > 0){
                haps1 <- setup_haps(win_length=length(het_idx))
                haps2 <- lapply(1:length(haps1), function(x) 1-haps1[[x]])
                allhaps <- c(haps1, haps2)
                mom_haps <- vector("list", 2^length(het_idx))
                mom_haps <- lapply(1:length(mom_haps), function(x) {
                    temhap <- mom_geno/2
                    temhap[het_idx] <- allhaps[[x]]
                    return(temhap)})
            }else{
                mom_haps <- list(mom_geno/2)
            }   
        }
        maxlog_hap_ockid(dad_hap, mom_geno, mom_haps, kid_geno=kgeno[[ped1$kid[x]]][winidx])
    })
    
    ### for selfed kids
    ped2 <- subset(ped, p1 == p2)
    maxlog2 <- lapply(1:nrow(ped2), function(x) {
        maxlog_hap_selfed_kid(haplotype=dad_hap, kid_geno=kgeno[[ped2$kid[x]]][winidx])
    })
    return(sum(unlist(maxlog1)) + sum(unlist(maxlog2)))
} 

#' @rdname phase_chunk
#' Find most likely phase of the dad for a kid at a window, return that probability
#' give this dad haplotype, mom genotype (thus all possible haplotypes) 
#' and a kid's diploid genotype over the window and returns maximum prob
#' Mendel is taken care of in the probs[[]] matrix already. 
maxlog_hap_ockid <- function(dad_hap, mom_geno, mom_haps, kid_geno){
    
    ### all possible genotypes of a kid
    allgeno1 <- lapply(1:length(mom_haps), function(x) dad_hap + mom_haps[[x]])
    allgeno2 <- lapply(1:length(mom_haps), function(x) (1-dad_hap) + mom_haps[[x]])
    allgenos <- c(allgeno1, allgeno2)
    
    ### return the possibility of the max genotype
    geno_probs <- lapply(1:length(allgenos), function(geno){
        sum( unlist(lapply(1:length(dad_hap), function(zz) {
            #log(probs[[2]] is the log prob. of kid's obs geno 
            #given the current phased geno and given dad is het. (which is why probs[[2]])
            tem <- probs[[2]][[ mom_geno[zz]+1 ]][allgenos[[geno]][zz]+1, kid_geno[zz]+1]
            return(log(tem))
        })))   
    })
    return(max(unlist(geno_probs)))
}

#' @rdname phase_chunk
maxlog_hap_selfed_kid <- function(haplotype, kid_geno){
    three_genotypes=list()
    haplotype=unlist(haplotype)
    three_genotypes[[1]]=haplotype+haplotype
    three_genotypes[[2]]=haplotype+(1-haplotype)
    three_genotypes[[3]]=(1-haplotype)+(1-haplotype)
    geno_probs=as.numeric() #prob of each of three genotypes
    for(geno in 1:3){
        #log(probs[[2]][three_genotypes,kidwin] is the log prob. of kid's obs geno 
        #given the current phased geno and given mom is het. (which is why probs[[2]])
        geno_probs[geno]=sum( sapply(1:length(haplotype), function(zz) 
            log( probs[[2]][[2]][three_genotypes[[geno]][zz]+1, kid_geno[zz]+1])))
    }
    ### may introduce error
    #if(length(which(geno_probs==max(geno_probs)))!=1){recover()}
    return(max(geno_probs))
}

#' @rdname phase_chunk
jump_win <- function(GBS.array, winstart, win_length, hetsites, haps){
    ### jump to next window
    if(length(hetsites) > (winstart + win_length - 1)){
        winidx <- hetsites[winstart:(winstart + win_length - 1)]
        win_hap <- infer_dip(GBS.array, winidx, haps, returnhap=FALSE)
    }else{
        winidx <- hetsites[winstart:length(hetsites)]
        mom_haps_tem <- setup_haps(win_length=length(winstart:length(hetsites)))
        win_hap <- infer_dip(GBS.array, winidx, haps=mom_haps_tem, returnhap=TRUE)    
    }
    return(win_hap)
}

#'
#' \code{Joining phased haplotypes chunks. } 
#'
#' Extending/joining the phased chunks of each chromosome generated by \code{phase_chunk}.
#'
#' @param GBS.array A GBS.array object generated from create_GBS.array() or sim.array() functions.
#' @param chunklist A list of haplotype chunks.
#' @param join_length A list of vectors of Kid's GBS data. 
#' Coded with 0, 1 and 2, which is the copy of alternative alleles. 
#' Missing data should be coded with 3.
#' @param verbose For function 'genomom', returnall=TRUE will return with all the information; 
#' returnall=FALSE will return
#' mom's genotype only.
#' 
#' @return return a data.frame with all the log likelihoods. 
#' Using function \code{momgeno} to extract mom's genotype. 
#'   
#'   See \url{https://github.com/yangjl/imputeR/blob/master/vignettes/imputeR-vignette.pdf} for more details.
#' @examples
#' 
#' 
#' GBS.array <- sim.array(size.array=50, numloci=1000)
#' haps <- setup_haps(win_length) 
#' chunklist <- phase_chuck(GBS.array, haps, verbose, win_length)
#' haplist <- join_chunks(GBS.array, chunklist, verbose, join_len)
#' 
join_chunks <- function(GBS.array, chunklist, verbose, join_len){
    outhaplist <- list(list())
    outhaplist[[1]] <- chunklist[[1]] ### store the extended haps: hap1, hap2 and idx
    i <- 1
    for(chunki in 2:length(chunklist)){
        if(verbose){ message(sprintf("###>>> join chunks [ %s and %s, total:%s] ...", 
                                     chunki-1, chunki, length(chunklist))) }
        # join two neighbor haplotype chunks
        oldchunk <- chunklist[[chunki-1]]
        newchunk <- chunklist[[chunki]]
        hapidx <- c(oldchunk[3], newchunk[3])
        #dad_haps <- list(c(oldchunk[[1]], newchunk[[1]]), c(oldchunk[[1]], newchunk[[2]]))
        dad_haps_lofl <- list(list(oldchunk[[1]], newchunk[[1]]), list(oldchunk[[1]], newchunk[[2]]))
        
        ## link previous and current chunks
        temhap <- link_dad_haps(GBS.array, dad_haps_lofl, hapidx, join_len)
        temhap <- c(temhap[[1]], temhap[[2]])
        if(!is.null(temhap)){
            outold <- outhaplist[[i]][[1]]
            outoldchunk <- outold[ (length(outold)-length(oldchunk[[1]])+1):length(outold)]
            outnewchunk <- temhap[(length(oldchunk[[1]])+1):length(temhap)]
            
            same <- sum(outoldchunk == temhap[1:length(oldchunk[[1]])])
            #same <- sum(mom_phase1[(length(mom_phase1)-8):length(mom_phase1)] == win_hap[1:length(win_hap)-1])
            outhaplist[[i]][[3]] <- c(outhaplist[[i]][[3]], newchunk[[3]])
            if(same == 0){ #totally opposite phase of last window
                #hap2[length(mom_phase2)+1] <- win_hap[length(win_hap)] 
                outhaplist[[i]][[1]] <- c(outhaplist[[i]][[1]], 1-outnewchunk)
                outhaplist[[i]][[2]] <- c(outhaplist[[i]][[2]], outnewchunk)
                
            } else if(same== length(oldchunk[[1]]) ){ #same phase as last window
                #mom_phase1[length(mom_phase1)+1] <- win_hap[length(win_hap)]
                outhaplist[[i]][[1]] <- c(outhaplist[[i]][[1]], outnewchunk)
                outhaplist[[i]][[2]] <- c(outhaplist[[i]][[2]], 1-outnewchunk)
            } else{
                stop(">>> Extending error !!!")
            }
        } else {
            i <- i +1
            outhaplist[[i]] <- haplist[[chunki]]
        } 
    }
    return(outhaplist)
}

#' @rdname join_chunks
#' 
link_dad_haps <- function(GBS.array, dad_haps_lofl, hapidx, join_len){
    ### hapidx: a list of idx [[1]] chunk0; [[2]]chunk1
    
    ### limit the join len to reduce computational burden
    if(length(hapidx[[1]]) > join_len ){
        upidx <- (length(hapidx[[1]])-join_len+1):length(hapidx[[1]])
    }else{
        upidx <- 1:length(hapidx[[1]])
    }
    if(length(hapidx[[2]]) > join_len ){
        downidx <- 1:join_len
    }else{
        upidx <- 1:length(hapidx[[2]])
    }
    
    ### get phase probs for each dad_haps
    phase_probs <- lapply(1:length(dad_haps_lofl), function(a) {
        dad_hap <- c(dad_haps_lofl[[a]][[1]][upidx], dad_haps_lofl[[a]][[2]][downidx])
        winidx <- c(hapidx[[1]][upidx], hapidx[[2]][downidx])   
        sum_max_log_1hap(GBS.array, winidx, dad_hap) 
    } )
    phase_probs <- unlist(phase_probs)
    #if multiple haps tie, return two un-phased haps
    if(length(which(phase_probs==max(phase_probs)))>1){
        return(NULL)
    } else {
        return(dad_haps_lofl[[which.max(phase_probs)]])
    }
}
