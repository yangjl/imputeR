---
title: "imputeR Documentation"
author: "Jinliang Yang"
date: "October 8, 2015"
output:
  pdf_document:
    number_sections: yes
    toc: yes
  html_document:
    toc: yes
  word_document: default
---

\newpage

# Introduction

## Crossing Scheme and Experimental Design

![alt text](scheme.pdf)

In this experiment, we selfed and outcrossed a set of ~70 teosinte landraces to get a progeny array composed of 4,875 individuals. The ~70 founders and all the progeny were genotyped using GBS. We also re-sequenced 20/70 founder lines (the others will be re-sequenced soon). Because of the high error rate of the GBS data, especially problematic for calling heterozygous sites, we employed a phasing and imputation strategy to infer the expected genotypes by combining parentage and GBS information.

This file is to document the `R` package we developed to solve the problems step by step.

## Install and Usage

Install devtools first, and then use devtools to install imputeR from github.

```{r, eval=FALSE}
# install and load devtools
devtools::install_github("hadley/devtools")
library(devtools)
# install and load imputeR
install_github("yangjl/imputeR")
library(imputeR)
```

## How to find help.
Within "R" console, type `?impute_parent` or `help(impute_parent)` to find help information about the function.

```{r}
?impute_parent
```

# Infer parent's genotype from GBS data

If we have parent's WGS data, this step can be skipped.

## Example
In the below toy example, we simulate a family of self and outcross progeny with 50 kids for 3 loci. We will assume 50% missing data, and 50% selfing rate. 

First we set some parameters for simulation
```{r}
    misscode = 3 # code for missing data
    numloci=3 # number of loci
    hom.error=0.02 #homozygous error rate
    het.error=0.8 #heterozygous error rate
    imiss=0.5 # % missing data
    selfing=0.5 # selfing rate
    size.array=50 # family size
    rec=0.25 # mean number of crossovers per chromosome
```

Then we make our focal parent
```{r}

    sfs <- getsfs() # make neutral SFS
    p <- sample(sfs, numloci, replace=TRUE) # get sample of allele freqs from SFS
    
    ### make focal_parent using a data.frame
    sim_focal <- data.frame(hap1=ran.hap(numloci,p), hap2=ran.hap(numloci,p))
```

Now we make our set of parents for each of our progeny. The first `outcrossed` parents are random, then next `size.array-outcrossed` are just the focal parent.
```{r}
    #first outcrossed
    outcrossed=rbinom(n=1,prob=(1-selfing),size=size.array)
    out_parents <- vector("list", outcrossed)
    out_parents <- lapply(1:outcrossed, function(i) data.frame(hap1=ran.hap(numloci,p), hap2=ran.hap(numloci,p)) )
    #now selfed
    self_parents <- vector("list", size.array-outcrossed)
    self_parents <- lapply(1:(size.array-outcrossed), function(i) sim_focal )
    #combine
    if(outcrossed==0){
        parent_array=self_parents  
    }else if (outcrossed==size.array){
        parent_array=out_parents
    }else{
        parent_array=c(out_parents,self_parents)
    }

    #now we make their diploid genotypes, we add the focal parent on to the end of the parents array
    parents<-lapply(parent_array, function(q) q[,1]+q[,2]  )
    parents[[size.array+1]]=c(sim_focal[,1]+sim_focal[,2])
    #finally, add error to make some crappy gbs_parents
    gbs_parents=lapply(parents, function(a) add_error(a,hom.error,het.error))
```

Now we make a progeny array for these parents.
```{r}
    progeny <- vector("list", size.array)
    #use the kid function!
    #each entry in progeny list has two vectors. [[1]] is true genotype, [[2]] is observed
    progeny <- lapply(1:size.array, function(a) 
        kid(p2=list(parent_array[[a]][,1], parent_array[[a]][,2]), p1=list(sim_focal[,1],sim_focal[,2]), 
            het.error, hom.error, rec, imiss, misscode))
    
    #now setup observed kids
    obs_kids=list()
    for(i in 1:size.array){ obs_kids[[i]]=progeny[[i]][[2]] }
```

Now we impute the focal parent
```{r}
    #which parent is our focal one? Here we set to end of parents array for ease
    obs_parent=size.array+1 #focal parent
    #which parents are the other parent of each offspring. These are in order since we simulated them that way.
    other_parents=c(1:outcrossed,rep(obs_parent,size.array-outcrossed)) #list of other parents

    #The stuff:
    inferred_geno_likes=impute_parent(gbs_parents, obs_parent, other_parents, obs_kids, hom.error=0.02, het.error=0.8,p)
    parentgeno(inferred_geno_likes, oddratio=0.6931472, returnall=TRUE)
```

In the resulting table, the first three columns are the probabilities of genotype `0, 1, 2`. The 4th column is the odd ratio of the highest divided by the 2nd highest probability. `gmax` parent's genotype with the highest probability. `gor` parent's genotype with the highest probability and `OR` bigger than the specified threshould.

## Real Data

To load `hdf5` file, you could install Vince's [tasselr](https://github.com/vsbuffalo/tasselr) and [ProgenyArray](https://github.com/vsbuffalo/ProgenyArray) packages. And then, following the below instructions.

```{r, eval=FALSE}
# install tasselr and ProgenyArray, if you fail to install it, checking all the dependencies.
library(devtools)
install_github("vsbuffalo/tasselr")
install_github("vsbuffalo/ProgenyArray")

library(parallel)
options(mc.cores=NULL)
# you need to specify the location where the packages were installed. 
load_all("~/bin/tasselr")
load_all("~/bin/ProgenyArray")

# Note: at least 64G memory was needed to load the hdf5 file
loading_h5_recode(h5file="largedata/teo.h5", save.file="largedata/out.RData")    
```

Then, for each parent, run `impute_parent` as in the toy example above. Note that you will need to supply a vector of allele frequencies at each locus estimated from the parents. If you do not supply this or leave `p=NULL`, a random allele frequency drawn from the neutral SFS will be used instead (this is Very Bad).  Since parents are coded as 0,1, or 2 for $N$ parents the allele frequency $p$ at a locus can be calculated as $\frac{\sum_{i=1}^Np_i}{2N}$.

----------


# Phasing Founder Genotypes  
$P(H|\theta) \propto P(\theta|H) \times P(H)$   
$P(H|\theta) \propto \left( \prod\limits_{i=1}^{k}{P(H'_k|H)} \right) \times P(H)$  
$P(H|\theta) \propto \left( \prod\limits_{i=1}^{k}\prod\limits_{l=1}^{n}{P(G'_{i,l}|H)} \right) \times P(H)$

- Where $\theta$ denotes observed data.
- $P(H)$ is the probability of the haplotype for a given window size of $n$.
- $P(G'_{i,l}|H)$ is the probability of kid $i$ at locus $l$ for a given haplotype $H$.
- The prior $P(H)$ is that all possible haplotypes of a given window size are equally likely.


----------

# Imputing and Phasing Kids  
$P(H_k|\theta) \propto P(\theta|H_k) \times P(H_k)$   
$P(H_k|\theta) \propto \left( \prod\limits_{i=k}{P(H'_k|H_k)} \right) \times P(H_k)$  
$P(H_k|\theta) \propto \left( \prod\limits_{i=k}\prod\limits_{l=1}^{n}{P(G'_{i,l}|H_k)} \right) \times P(H_k)$

- Where $\theta$ denotes observed data.
- $P(H)$ is the probability of the haplotype for a given window size of $n$.
- $P(G'_{i,l}|H)$ is the probability of kid $i$ at locus $l$ for a given haplotype $H$.
- The prior $P(H)$ is that all possible haplotypes of a given window size are equally likely.

```{r, eval=FALSE}
phase <- read.csv("../data/sim_phasing_res.csv")

hist(phase$er, breaks=30, main="Simulation (N=100)",col="#faebd7", xlab="Phasing Error Rate")
abline(v=mean(phase$er), col="red", lwd=2)
abline(v=median(phase$er), col="darkblue", lwd=2)
```

----------

# Phasing Dad of outcrossing progeny array  
$P(H_d|\theta) \propto P(\theta|H_d) \times P(H_d)$   
$P(H_d|\theta) \propto \left( \prod\limits_{i=1}^{k}{P(H'_k|H_d, H_m)} \right) \times P(H_m) \times P(H_d)$  
$P(H|\theta) \propto \left( \prod\limits_{i=1}^{k}\prod\limits_{l=1}^{n}{P(G'_{i,l}|H)} \right) \times P(H)$

- Where $\theta$ denotes observed data.
- $P(H_d)$ is the probability of the dad's haplotype for a given window size of $n$.
- $P(G'_{i,l}|H)$ is the probability of kid $i$ at locus $l$ for a given haplotype $H$.
- The prior $P(H)$ is that all possible haplotypes of a given window size are equally likely.


----------
